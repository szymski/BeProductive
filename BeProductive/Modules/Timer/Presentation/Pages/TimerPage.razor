@page "/timer"
@using BeProductive.Modules.Timer.Infrastructure
@using Serilog
@inject TimerService TimerService
@inject AudioService AudioService
@implements IDisposable
@{
    Layout.Title = "Pomodoro timer";
}

<div class="timer-wrapper">
    <div class="timer">
        <span>
            @if (!_isRunning)
            {
                @_duration.ToString("mm\\:ss")
            }
            else
            {
                @_timeLeft.ToString("mm\\:ss")
            }
        </span>
    </div>
    <div class="buttons">
        <Space>
            <SpaceItem>
                @* TODO: Using key to update button color, can't change at runtime. Maybe report a bug. *@
                <Button @key="_isRunning" Type="@ButtonType.Primary" Color=@(!_isRunning ? Color.Green7 : Color.None) Size="@ButtonSize.Large" Disabled=@(_isRunning) OnClick="OnStartClick">Start</Button>
            </SpaceItem>
            <SpaceItem>
                <Button Type="@ButtonType.Primary" Danger Size="@ButtonSize.Large" Disabled=@(!_isRunning) OnClick="OnStopClick">Stop</Button>
            </SpaceItem>
        </Space>
    </div>
</div>

@code {
    private bool _isRunning = false;

    private TimeSpan _duration = TimeSpan.FromSeconds(5);
    private TimeSpan _timeLeft = TimeSpan.Zero;

    private DateTime _startTime;
    private DateTime _endTime;

    protected override void OnInitialized()
    {
        _isRunning = TimerService.IsRunning;

        TimerService.TimerTick += OnTimerTick;
        TimerService.TimerFinished += OnTimerFinished;
    }

    private async Task OnStartClick()
    {
        _isRunning = true;
        _timeLeft = _duration;
        _startTime = DateTime.Now;
        _endTime = _startTime + _duration;
        TimerService.Start(_duration);
        
        await AudioService.PlaySoundEffect(SoundEffect.TimerStart);
    }

    private async Task OnStopClick()
    {
        _isRunning = false;
        TimerService.Stop();
        await AudioService.PlaySoundEffect(SoundEffect.TimerPause);
    }

    private void OnTimerTick(object? sender, EventArgs e)
    {
        _timeLeft = (_endTime - DateTime.Now).Add(TimeSpan.FromSeconds(1));
        InvokeAsync(StateHasChanged);
    }

    private void OnTimerFinished(object? sender, EventArgs e)
    {
        _isRunning = false;
        Log.Warning("Time finished in razor");
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        TimerService.TimerTick -= OnTimerTick;
        TimerService.TimerFinished -= OnTimerFinished;
    }

}